#!/usr/bin/python3
# -*- coding: utf-8 -*-

"""
Copyright Â© 2009-2014 The Caffeine Developers

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""


import argparse
import logging
import pkg_resources
import signal
import sys

from ewmh import EWMH as EWMH_CLASS
from gi.repository import GObject, Gtk, GLib
from subprocess import call
from Xlib.display import Display

__program__ = 'caffeine'
__description__ = 'Prevent desktop idleness in fullscreen mode.'
__version__ = pkg_resources.require(__program__)[0].version


class Caffeine(GObject.GObject):
    def __init__(self):
        GObject.GObject.__init__(self)
        self.windowID = None

        GObject.timeout_add(get_timeout(), self._check_for_fullscreen)

    def _check_for_fullscreen(self):
        """Check for an active fullscreen window and respond appropriately."""
        win = EWMH.getActiveWindow()
        windowID = hex(win.id)

        inhibit = False
        if win is not None:
            try:
                inhibit = '_NET_WM_STATE_FULLSCREEN' in EWMH.getWmState(win, str=True)
            except:
                pass

        # if inhibition state has changed, take action
        if (self.windowID is not None) != inhibit:
            if inhibit:
                self.windowID = windowID
                call(['caffeine-screensaver', 'suspend', self.windowID], timeout=5)
                LOGGER.info('inhibiting desktop idleness')
            else:
                self.release()
        # if windowID has changed but inhibition state remains True, inhibit new windowID
        elif windowID != self.windowID and inhibit:
            self.windowID = windowID
            call(['caffeine-screensaver', 'suspend', self.windowID], timeout=5)

        # return True so timeout is rerun
        return True

    def release(self):
        """Resume the screensaver and DPMS after being suspended."""
        if self.windowID is not None:
            call(['caffeine-screensaver', 'resume', self.windowID], timeout=5)
            LOGGER.info('no longer inhibiting desktop idleness')
            self.windowID = None


# class Caffeine(GObject.GObject):
#     def __init__(self):
#         GObject.GObject.__init__(self)
#         self.windowID = None

#         GObject.timeout_add(get_timeout(), self._check_for_fullscreen)

#     def _check_for_fullscreen(self):
#         """Check for an active fullscreen window and respond appropriately."""
#         win = EWMH.getActiveWindow()
#         windowID = hex(win.id)

#         inhibit = False
#         if win is not None:
#             try:
#                 inhibit = '_NET_WM_STATE_FULLSCREEN' in EWMH.getWmState(win, str=True)
#             except:
#                 pass

#         # if inhibition state has changed, take action
#         if windowID != self.windowID or (self.windowID is not None) != inhibit:
#             if inhibit:
#                 self.windowID = hex(win.id)
#                 call(['caffeine-screensaver', 'suspend', self.windowID], timeout=5)
#                 LOGGER.info('inhibiting desktop idleness')
#             else:
#                 self.release()

#         # return True so timeout is rerun
#         return True

#     def release(self):
#         """Resume the screensaver and DPMS after being suspended."""
#         if self.windowID is not None:
#             call(['caffeine-screensaver', 'resume', self.windowID], timeout=5)
#             LOGGER.info('no longer inhibiting desktop idleness')
#             self.windowID = None


def get_timeout():
    """Determine the program's timeout interval in milliseconds."""

    # seconds = Display().get_screen_saver().interval
    seconds = Display().get_screen_saver().timeout

    # default to 30s if screensaver is off otherwise use t minus 10s
    return (seconds - 10) * 1000 if seconds > 10 else 60000


# adapted from http://stackoverflow.com/questions/26388088/python-gtk-signal-handler-not-working
def init_signal():
    def signal_action(sig):
        CAFFEINE.release()
        sys.exit(1)

    def idle_handler(*args):
        GLib.idle_add(signal_action, priority=GLib.PRIORITY_HIGH)

    def handler(*args):
        signal_action(args[0])

    def install_glib_handler(sig):
        # GLib.unix_signal_add was added in glib 2.36
        GLib.unix_signal_add(GLib.PRIORITY_HIGH, sig, handler, sig)

    for sig in [signal.SIGINT, signal.SIGTERM, signal.SIGHUP]:
        signal.signal(sig, idle_handler)
        GLib.idle_add(install_glib_handler, sig, priority=GLib.PRIORITY_HIGH)


PARSER = argparse.ArgumentParser(
    add_help=False,
    description=__description__,
    prog=__program__,
    usage='%(prog)s')
PARSER.add_argument(
    '--align',
    action='store_true',
    dest='align',
    help=argparse.SUPPRESS)
PARSER.add_argument(
    '-h', '--help',
    action='help',
    help=argparse.SUPPRESS)
PARSER.add_argument(
    '-q', '--quiet',
    action='store_true',
    dest='quiet',
    help='silence normal output')
PARSER.add_argument(
    '-t', '--timestamp',
    action='store_true',
    dest='timestamp',
    help='timestamp log entries')
PARSER.add_argument(
    '-V', '--version',
    action='version',
    version=__program__ + ' ' + __version__)

OPTIONS = PARSER.parse_args()

# set up logging
SPACES = ' ' * (11 if OPTIONS.align else 1)
STR = '(%(name)s)' + SPACES + '%(levelname)s: %(message)s'

if OPTIONS.timestamp:
    FMT = ['%(asctime)s.%(msecs)03d ' + STR, '%Y-%m-%d %H:%M:%S']
else:
    FMT = [STR]

LOGGER = logging.getLogger(__program__)
STREAM = logging.StreamHandler()
FORMAT = logging.Formatter(*FMT)
STREAM.setFormatter(FORMAT)
LOGGER.addHandler(STREAM)

if not OPTIONS.quiet:
    LOGGER.setLevel(logging.INFO)

# # set up logging
# LOGGER = logging.getLogger(__program__)
# STREAM = logging.StreamHandler()
# FORMAT = logging.Formatter('%(levelname)s:%(name)s: %(message)s')
# STREAM.setFormatter(FORMAT)
# LOGGER.addHandler(STREAM)
# LOGGER.setLevel(logging.WARNING if OPTIONS.quiet else logging.INFO)

EWMH = EWMH_CLASS()
GObject.threads_init()
CAFFEINE = Caffeine()
init_signal()
Gtk.main()
