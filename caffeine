#!/usr/bin/python3
# -*- coding: utf-8 -*-

"""
Copyright Â© 2009-2015 The Caffeine Developers

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""


import argparse
import logging
import pkg_resources
import signal
import sys

from ewmh import EWMH as EWMH_CLASS
from gi.repository import GObject, Gtk, GLib
from subprocess import call
from Xlib.display import Display

__program__ = 'caffeine'
__description__ = 'Prevent desktop idleness in fullscreen mode.'
__version__ = pkg_resources.require('caffeine-reloaded')[0].version


class Caffeine(GObject.GObject):

    def __init__(self):
        GObject.GObject.__init__(self)

        self.activated = False
        self.root_id = hex(DISPLAY.screen().root.id)

        GObject.timeout_add(get_timeout(), self.execute)

    def execute(self):
        """Check for an active fullscreen window and respond appropriately."""

        fullscreen = is_fullscreen()

        # if inhibition state has changed, take action
        if self.activated != fullscreen:
            if fullscreen:
                self.inhibit()
            else:
                self.resume()

        return True

    def inhibit(self):
        """Inhibit the screensaver."""

        self.activated = True
        LOGGER.info('inhibiting desktop idleness')
        call(['caffeine-screensaver', 'suspend', self.root_id])

    def resume(self):
        """Resume the screensaver after being suspended."""

        if self.activated:
            self.activated = False
            LOGGER.info('no longer inhibiting desktop idleness')
            call(['caffeine-screensaver', 'resume', self.root_id])


# class Caffeine(GObject.GObject):
#     def __init__(self):
#         GObject.GObject.__init__(self)

#         self.window = None

#         GObject.timeout_add(get_timeout(), self.execute)

#     def execute(self):
#         """Check for an active fullscreen window and respond appropriately."""

#         activated = self._is_activated()
#         alive = self._is_window_alive()
#         inhibit = self._is_fullscreen()

#         # if inhibition state has changed, take action
#         if alive != inhibit:
#             if inhibit:
#                 if activated:
#                     LOGGER.info('reinhibiting desktop idleness')
#                 else:
#                     LOGGER.info('inhibiting desktop idleness')

#                 self.window = EWMH.getActiveWindow()
#                 call(['caffeine-screensaver', 'suspend', self._get_window_id])
#             else:
#                 self.resume()
#         # if fullscreen window has ended, take note
#         elif not alive and activated:
#             self.window = None
#             LOGGER.info('no longer inhibiting desktop idleness')

#         return True

#     @property
#     def _get_window_id(self):
#         """Return the window id of self.window."""

#         return hex(self.window.id)

#     def _is_activated(self):
#         return self.window is not None

#     def _is_fullscreen(self):
#         """Check whether active window is fullscreen."""

#         from Xlib.error import BadWindow

#         window = EWMH.getActiveWindow()

#         try:
#             return '_NET_WM_STATE_FULLSCREEN' in EWMH.getWmState(window, str=True)
#         except BadWindow:
#             pass

#         return False

#     def _is_window_alive(self):
#         """Check whether self.window is currently alive."""

#         from Xlib.error import BadWindow

#         try:
#             if self._is_activated() and self.window.get_wm_state() is not None:
#                 return True
#         except BadWindow:
#             pass

#         return False

#     def resume(self):
#         """Resume the screensaver and DPMS after being suspended."""

#         if self._is_activated():
#             self.window = None
#             LOGGER.info('no longer inhibiting desktop idleness')

#         if self._is_window_alive():
#             call(['caffeine-screensaver', 'resume', self._get_window_id])


def get_timeout():
    """Determine the program's timeout interval in milliseconds."""

    # seconds = DISPLAY.get_screen_saver().interval
    seconds = DISPLAY.get_screen_saver().timeout

    LOGGER.info('screen saver timeout = %s s', seconds)

    # default to 30s if screensaver is off otherwise use t minus 10s
    interval = (seconds - 10) * 1000 if seconds > 10 else 60000

    LOGGER.info('GObject interval = %s ms', interval)

    return interval


# adapted from http://stackoverflow.com/questions/26388088/python-gtk-signal-handler-not-working
def init_signal():
    def signal_action(sig):
        CAFFEINE.resume()
        sys.exit(1)

    def idle_handler(*args):
        GLib.idle_add(signal_action, priority=GLib.PRIORITY_HIGH)

    def handler(*args):
        signal_action(args[0])

    def install_glib_handler(sig):
        # GLib.unix_signal_add was added in glib 2.36
        GLib.unix_signal_add(GLib.PRIORITY_HIGH, sig, handler, sig)

    for sig in [signal.SIGINT, signal.SIGTERM, signal.SIGHUP]:
        signal.signal(sig, idle_handler)
        GLib.idle_add(install_glib_handler, sig, priority=GLib.PRIORITY_HIGH)


def is_fullscreen():
    """Check whether active window is fullscreen."""

    from Xlib.error import BadWindow

    window = EWMH.getActiveWindow()

    try:
        return '_NET_WM_STATE_FULLSCREEN' in EWMH.getWmState(window, str=True)
    except BadWindow:
        pass

    return False


PARSER = argparse.ArgumentParser(
    add_help=False,
    description=__description__,
    prog=__program__,
    usage='%(prog)s [OPTION]...')
PARSER.add_argument(
    '--align',
    action='store_true',
    dest='align',
    help=argparse.SUPPRESS)
PARSER.add_argument(
    '-h', '--help',
    action='help',
    help=argparse.SUPPRESS)
PARSER.add_argument(
    '-q', '--quiet',
    action='store_true',
    dest='quiet',
    help='suppress normal output')
PARSER.add_argument(
    '-t', '--timestamp',
    action='store_true',
    dest='timestamp',
    help='timestamp log entries')
PARSER.add_argument(
    '-V', '--version',
    action='version',
    version=__program__ + ' ' + __version__)

OPTIONS = PARSER.parse_args()

# set up logging
SPACES = ' ' * (11 if OPTIONS.align else 1)
STR = '(%(name)s)' + SPACES + '%(levelname)s: %(message)s'

if OPTIONS.timestamp:
    FMT = ['%(asctime)s.%(msecs)03d ' + STR, '%Y-%m-%d %H:%M:%S']
else:
    FMT = [STR]

LOGGER = logging.getLogger(__program__)
STREAM = logging.StreamHandler()
FORMAT = logging.Formatter(*FMT)
STREAM.setFormatter(FORMAT)
LOGGER.addHandler(STREAM)

if not OPTIONS.quiet:
    LOGGER.setLevel(logging.INFO)

# # set up logging
# LOGGER = logging.getLogger(__program__)
# STREAM = logging.StreamHandler()
# FORMAT = logging.Formatter('%(levelname)s:%(name)s: %(message)s')
# STREAM.setFormatter(FORMAT)
# LOGGER.addHandler(STREAM)
# LOGGER.setLevel(logging.WARNING if OPTIONS.quiet else logging.INFO)

DISPLAY = Display()
EWMH = EWMH_CLASS()
GObject.threads_init()
CAFFEINE = Caffeine()
init_signal()
Gtk.main()
